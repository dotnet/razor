# VS Code Integration Tests - Copilot Instructions

## Keyboard Input

**All keyboard input should go through `testServices.Input`**, not `testServices.Playwright.Page.Keyboard` directly. This applies to **both tests and services**. Only `InputService` itself should use Playwright directly.

This ensures:
- Consistent abstractions
- Cross-platform compatibility (Control vs Meta for primary modifier)
- Single place to manage platform differences

### Available Methods

- `testServices.Input.TypeAsync(text)` - Type text at cursor
- `testServices.Input.PressAsync(key)` - Press a key (e.g., "Enter", "Escape", "ArrowLeft")
- `testServices.Input.PressWithPrimaryModifierAsync(key)` - Press Ctrl+key (Windows/Linux) or Cmd+key (macOS)
- `testServices.Input.PressWithShiftPrimaryModifierAsync(key)` - Press Ctrl+Shift+key or Cmd+Shift+key
- `testServices.Input.ClickWithPrimaryModifierAsync(x, y)` - Ctrl+Click (Windows/Linux) or Cmd+Click (macOS)

Or use higher-level service methods like `testServices.Editor.SaveAsync()`.

### Examples

```csharp
// ✅ Correct - in tests OR services
await testServices.Input.PressAsync("Escape");
await testServices.Input.PressWithPrimaryModifierAsync("s");  // Save (Ctrl+S or Cmd+S)
await testServices.Editor.SaveAsync();  // Even better - use high-level method

// ❌ Wrong - anywhere except InputService itself
await testServices.Playwright.Page.Keyboard.PressAsync("Enter");
await testServices.Playwright.Page.Keyboard.PressAsync("Control+s");
```

## Cross-Platform Considerations

- Use `PressWithPrimaryModifierAsync` for shortcuts that use Ctrl on Windows/Linux and Cmd on macOS
- Standard keys like "Enter", "Escape", "Tab", "ArrowLeft" etc. work across all platforms
- The InputService handles the platform detection automatically

## Reading Editor Content

**Use `GetEditorTextAsync()` which saves the file and reads from disk.** Do NOT attempt to scrape text from the Monaco DOM - Monaco only renders visible lines and uses virtualization, making DOM-based text extraction unreliable.

```csharp
// ✅ Correct
var text = await testServices.Editor.GetEditorTextAsync();

// ❌ Wrong - DOM scraping is unreliable due to Monaco virtualization
var lines = await page.QuerySelectorAllAsync(".view-line");
```

## Service Responsibilities

| Service | Purpose |
|---------|---------|
| `InputService` | Raw keyboard/mouse input (platform-aware) |
| `EditorService` | High-level editor operations (open file, go to line, save, get text, etc.) |
| `CompletionServices` | IntelliSense completion operations |
| `HoverServices` | Hover/Quick Info operations |
| `DiagnosticsServices` | Error squiggle detection and Problems panel |
| `NavigationServices` | Go to Definition, Find References |
| `RazorService` | Razor language server readiness |

## Test Structure

1. Tests should NOT contain scenario-specific code in services
2. Services provide generic helpers; tests contain the specific verification logic
3. All tests extend `VSCodeIntegrationTestBase` which handles VS Code lifecycle
4. Use `testServices.Logger.Log()` for debug output visible in test results
5. **Always wrap test logic in `ScreenshotOnFailureAsync`** to capture screenshots on failure
6. **No cleanup needed** - each test runs in an isolated VS Code instance

### Test Pattern

Always use the expression-bodied style with `ScreenshotOnFailureAsync`:

```csharp
[Fact]
public Task MyTest_DoesExpectedThing() => ScreenshotOnFailureAsync(async () =>
{
    // Arrange
    await TestServices.Editor.OpenFileAsync("Components/Pages/Counter.razor");

    // Act
    var result = await TestServices.SomeService.DoSomethingAsync();

    // Assert
    Assert.NotNull(result);
});
```

This ensures:
- Screenshots are automatically captured when tests fail
- Consistent test structure across all test files
- Easier debugging in CI when failures occur
