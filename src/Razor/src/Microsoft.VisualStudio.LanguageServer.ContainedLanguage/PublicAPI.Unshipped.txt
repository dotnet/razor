#nullable enable
abstract Microsoft.VisualStudio.LanguageServer.ContainedLanguage.MessageInterception.InterceptorManager.ProcessInterceptorsAsync<T>(string! methodName, T message, string! contentType, System.Threading.CancellationToken cancellationToken) -> System.Threading.Tasks.Task<T?>!
Microsoft.VisualStudio.LanguageServer.ContainedLanguage.LSPDocument.TryGetVirtualDocument<TVirtualDocument>(System.Uri! virtualDocumentUri, out TVirtualDocument? virtualDocument) -> bool
Microsoft.VisualStudio.LanguageServer.ContainedLanguage.LSPDocumentSnapshot.TryGetAllVirtualDocuments<TVirtualDocument>(out TVirtualDocument![]? virtualDocuments) -> bool
Microsoft.VisualStudio.LanguageServer.ContainedLanguage.MessageInterception.InterceptionMiddleLayer2
Microsoft.VisualStudio.LanguageServer.ContainedLanguage.MessageInterception.InterceptionMiddleLayer2.CanHandle(string! methodName) -> bool
Microsoft.VisualStudio.LanguageServer.ContainedLanguage.MessageInterception.InterceptionMiddleLayer2.HandleNotificationAsync<TMessage>(string! methodName, TMessage message, System.Func<TMessage, System.Threading.Tasks.Task!>! sendNotification) -> System.Threading.Tasks.Task!
Microsoft.VisualStudio.LanguageServer.ContainedLanguage.MessageInterception.InterceptionMiddleLayer2.HandleRequestAsync<TRequest, TResponse>(string! methodName, TRequest methodParam, System.Func<TRequest, System.Threading.Tasks.Task<TResponse?>!>! sendRequest) -> System.Threading.Tasks.Task<TResponse?>!
Microsoft.VisualStudio.LanguageServer.ContainedLanguage.MessageInterception.InterceptionMiddleLayer2.InterceptionMiddleLayer2(Microsoft.VisualStudio.LanguageServer.ContainedLanguage.MessageInterception.InterceptorManager! interceptorManager, string! contentType) -> void
Microsoft.VisualStudio.LanguageServer.ContainedLanguage.MessageInterception.InterceptionResult.ChangedToken.get -> object?
Microsoft.VisualStudio.LanguageServer.ContainedLanguage.MessageInterception.InterceptionResult.InterceptionResult(object? newToken, bool changedDocumentUri) -> void
Microsoft.VisualStudio.LanguageServer.ContainedLanguage.MessageInterception.InterceptorManager.ProcessInterceptorsAsync(string! methodName, Newtonsoft.Json.Linq.JToken! message, string! contentType, System.Threading.CancellationToken cancellationToken) -> System.Threading.Tasks.Task<Newtonsoft.Json.Linq.JToken?>!
virtual Microsoft.VisualStudio.LanguageServer.ContainedLanguage.LSPDocument.UpdateVirtualDocument<TVirtualDocument>(TVirtualDocument! virtualDocument, System.Collections.Generic.IReadOnlyList<Microsoft.VisualStudio.Text.ITextChange!>! changes, int hostDocumentVersion, object? state) -> Microsoft.VisualStudio.LanguageServer.ContainedLanguage.LSPDocumentSnapshot!
virtual Microsoft.VisualStudio.LanguageServer.ContainedLanguage.LSPDocumentManager.RefreshVirtualDocuments() -> void
virtual Microsoft.VisualStudio.LanguageServer.ContainedLanguage.MessageInterception.MessageInterceptor.ApplyChangesAsync(Newtonsoft.Json.Linq.JToken! message, string! containedLanguageName, System.Threading.CancellationToken cancellationToken) -> System.Threading.Tasks.Task<Microsoft.VisualStudio.LanguageServer.ContainedLanguage.MessageInterception.InterceptionResult>!
virtual Microsoft.VisualStudio.LanguageServer.ContainedLanguage.MessageInterception.MessageInterceptor.ApplyChangesAsync<T>(T message, string! containedLanguageName, System.Threading.CancellationToken cancellationToken) -> System.Threading.Tasks.Task<Microsoft.VisualStudio.LanguageServer.ContainedLanguage.MessageInterception.InterceptionResult>!
virtual Microsoft.VisualStudio.LanguageServer.ContainedLanguage.VirtualDocumentFactory.TryCreateMultipleFor(Microsoft.VisualStudio.Text.ITextBuffer! hostDocumentBuffer, out Microsoft.VisualStudio.LanguageServer.ContainedLanguage.VirtualDocument![]? virtualDocuments) -> bool
